import DaiContract from "./contracts/DAI.json";
import SemaphoreUserRegistryContract from "./contracts/SemaphoreUserRegistry.json";
import { ZKEdDSAEventTicketPCDPackage } from "@pcd/zk-eddsa-event-ticket-pcd";
import { NextApiRequest, NextApiResponse } from "next";
import { createPublicClient, createWalletClient, http, isAddress, parseEther } from "viem";
import { formatEther, hexToBigInt } from "viem";
import { privateKeyToAccount } from "viem/accounts";
import { optimism } from "viem/chains";

const localWalletClient = createWalletClient({
  chain: optimism,
  transport: http(),
});

const client = createPublicClient({
  chain: optimism,
  transport: http(),
});

// const accounts = await localWalletClient.getAddresses();
// const account = mnemonicToAccount(process.env.MNEMONIC as string);
const account = privateKeyToAccount(`0x${process.env.WALLET_PRIVATE_KEY}`);

const gasDrop = parseEther("0.0003");
const daiDrop = parseEther("5");

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  try {
    const pcd = await ZKEdDSAEventTicketPCDPackage.deserialize(req.body.pcd);
    const address = req.body.address;
    const semaphoreId = pcd.claim.partialTicket.attendeeSemaphoreId;
    const transactionCount = await client.getTransactionCount({
      address: account.address,
    });
    console.log(transactionCount);

    // ## Validations
    if (!isAddress(address)) {
      return res.status(401).send("Invalid address");
    }

    if (!(await ZKEdDSAEventTicketPCDPackage.verify(pcd))) {
      console.error(`[ERROR] ZK ticket PCD is not valid`);
      return res.status(200).json({
        error: true,
        pcd: pcd,
        message: `ZK ticket no es valido!`,
      });
    }

    if ("1ebfb986fbac5113f8e2c72286fe9362f8e7d211dbc68227a468d7b919e75003" != pcd.claim.signer[0]) {
      console.error(`[ERROR] PCD is not signed by Zupass`);
      return res.status(200).json({
        error: true,
        pcd: pcd,
        message: `PCD no esta firmado por Zupass!`,
      });
    }

    if (!pcd.claim.partialTicket.isConsumed) {
      console.error(`[ERROR Frontend] Ticket not consumed`);
      return res.status(200).json({
        error: true,
        pcd: pcd,
        message: `Ticket no esta consumido!`,
      });
    }

    // TODO: Use real nonce generated by the server
    if (pcd.claim.watermark.toString() !== hexToBigInt(address as `0x${string}`).toString()) {
      console.error(`[ERROR] PCD watermark doesn't match`);
      return res.status(200).json({
        error: true,
        pcd: pcd,
        message: `El watermark no coincide !`,
      });
    }

    // TODO: Check that the event id is the one we expect

    const isVerified = await client.readContract({
      address: process.env.SEMAPHORE_USER_REGISTRY_ADDRESS as string,
      abi: SemaphoreUserRegistryContract.abi,
      functionName: "isVerifiedSemaphoreId",
      args: [semaphoreId],
    });

    if (isVerified) {
      console.error(`[ERROR] User already registred`);
      // return res.status(401).send("User already registred");
      return res.status(200).json({
        error: true,
        pcd: pcd,
        message: `Usuario ya registrado!`,
      });
    }

    // ## Actions
    const registryResult = await localWalletClient.writeContract({
      account: account,
      address: SemaphoreUserRegistryContract.address,
      abi: SemaphoreUserRegistryContract.abi,
      functionName: "addUser",
      args: [address, semaphoreId],
      nonce: transactionCount,
    });

    // Send ETH to the user. This is just for testing purposes, and it could be any backend action.
    await localWalletClient.sendTransaction({
      to: req.body.address,
      value: gasDrop,
      account: account,
      nonce: transactionCount + 1,
    });

    await localWalletClient.writeContract({
      account: account,
      address: DaiContract.address,
      abi: DaiContract.abi,
      functionName: "transfer",
      args: [address, daiDrop],
      nonce: transactionCount + 2,
    });

    return res.status(200).json({
      message: `ðŸŽ‰ PCD verificado! ahora puedes votar! recibiste ${formatEther(gasDrop)} ETH y ${formatEther(
        daiDrop,
      )} DAIs en tu cuenta ${address}!`,
      txHash: registryResult,
    });
  } catch (e) {
    return res.status(200).json({
      error: true,
      pcd: null,
      message: e,
    });
  }
}
